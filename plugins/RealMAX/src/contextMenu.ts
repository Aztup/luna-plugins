import { actions } from "@neptune";
import { trace } from ".";

import { chunkArray } from "@inrixia/helpers";
import { ContextMenu, interceptPromise } from "@inrixia/lib";

import type { ItemId } from "neptune-types/tidal";

const maxButton = document.createElement("button");
maxButton.type = "button";
maxButton.role = "menuitem";
maxButton.textContent = "";
maxButton.id = "realMax-button";
maxButton.className = "context-button"; // Set class name for styling

const maxNewPlaylistSize = 450;

export const unloadContextMenu = ContextMenu.onOpen(async (mediaCollection, contextMenu) => {
	maxButton.remove();

	const itemCount = await mediaCollection.mediaItemsCount();
	if (itemCount === 0) return;

	maxButton.textContent = itemCount > 1 ? `[RealMAX] Process ${itemCount} tracks` : "[RealMAX] Process track";
	contextMenu.appendChild(maxButton);

	maxButton.onclick = async () => {
		maxButton.onclick = () => {};
		let trackIds: ItemId[] = [];
		const sourceTitle = await mediaCollection.title();
		maxButton.textContent = `[RealMAX] Loading...`;
		for await (const mediaItem of await mediaCollection.mediaItems()) {
			const maxItem = await mediaItem.max();
			if (maxItem === undefined) {
				maxButton.textContent = `[RealMAX] ${trackIds.length}/${itemCount} done.`;
				continue;
			}
			trackIds.push(maxItem.id);
			trace.msg.log(`Found Max quality for ${maxItem.title} in ${sourceTitle}!`);
		}
		const [{ playlist }] = await interceptPromise(
			() =>
				actions.folders.createPlaylist({
					description: "Automatically generated by RealMAX",
					folderId: "root",
					fromPlaylist: undefined,
					isPublic: false,
					title: `[RealMAX] ${sourceTitle}`,
					// @ts-expect-error This works lol
					ids: trackIds.length > maxNewPlaylistSize ? undefined : trackIds,
				}),
			["content/LOAD_PLAYLIST_SUCCESS"],
			["content/LOAD_PLAYLIST_FAIL"]
		);
		if (trackIds.length > maxNewPlaylistSize) {
			for (const trackIdsChunk of chunkArray(trackIds, maxNewPlaylistSize)) {
				await interceptPromise(
					() =>
						actions.content.addMediaItemsToPlaylist({
							addToIndex: -1,
							mediaItemIdsToAdd: trackIdsChunk,
							onDupes: "ADD",
							playlistUUID: playlist.uuid!,
						}),
					["content/ADD_MEDIA_ITEMS_TO_PLAYLIST_SUCCESS"],
					["content/ADD_MEDIA_ITEMS_TO_PLAYLIST_FAIL"]
				);
			}
		}
		if (playlist?.uuid === undefined) {
			return trace.msg.err(`Failed to create playlist "${sourceTitle}"`);
		}
		trace.msg.err(`Successfully created playlist "${sourceTitle}" - Found ${trackIds.length} replacements!`);
	};
});
